---
bg: "Diary.jpg"
layout: post
title:  "그림 맞추기 게임(오늘 뭐 없나..?) - 게임 시퀀스"
crawlertitle: "그림 맞추기 게임(오늘 뭐 없나..?) - 1"
summary: "그림 맞추기 게임(오늘 뭐 없나..?) - 1"
date: 2021-01-26 16:30:00 +0900
category: Diary
author: Err0rCode7
---

최근 그림 맞추기 게임(오늘 뭐 없나..?) 프로젝트를 진행하고 있다.

큰 기능을 단위로 개발을 진행하게 되었는데

본격적으로 가장 메인 기능인 `게임 페이지` 기능에 시퀀스를 만드는 회의 전에 개인적으로 어떤 시퀀스로 동작을 해야할지 정리를 해보았고 내용을 기록하고자 포스팅을 한다.

---

## 채팅
---

한 사람이 입력한 채팅이 모두에게 보여야 함
-> WebSocket or Socket.io 필요

1. 클라이언트에 소켓 통신요청을 받을 수 있는 콜백 서버 생성

2. 클라이언트가 방 참여를 하게 된 순간 서버에 소켓 연결
	- `Q1`. 서버에서는 각각의 방에 따라 소켓을 나누는 것이 필요하다. 또는 한 개의 소켓을 이용해서 여러 소켓으로 나누는 효과를 만드는 것이 필요하다. 이를 해결해야한다.

	0. 게임 방 입장 시 클라이언트는 서버에게 소켓 연결을 시도한다.
	
	1. 클라이언트로부터 1번방에대한 연결요청을 받는다.
	2. 서버는 소켓 연결 요청을 상시 대기하고 있다가 요청이 오면 받아서 해당 하는 방 번호와 연결
	3. 연결이 완료되면 서버에서는 각 방마다 클라이언트에 입력을 받아오고 모두에게 브로드캐스팅한다.
	4. 클라이언트에서는 서버로부터 브로드캐스팅해서 온 내용 웹에 나타낸다

- **발생하는 문제**
	- `Q1`
		- 소켓을 연결할 때 각 채널(프로세스 또는 쓰레드)을 	나누는 방법을 모른다.
		- 만약 각 채널(프로세스 또는 쓰레드)을 나누지 않고 하나의 소켓 서버로 사용을 한다. 소켓서버 하나에 할당할 수 있는 연결의 수가 무수히 많아지게 된다.
	- `Q2`
		- 로드밸런서가 어떤 것인지 정확히 알아본다.

## 게임 로직
---
채팅에 포함되어야 하는 내용이지만 분리해서 정리를 진행
- `Q1`. 정답을 입력하고 확인하는 내용은 모두 소켓으로 양방향 통신이 이루어진다. 그렇다면 턴 종료, 다음 라운드 시작, 모든 라운드 종료에 대한 통신을 어떤 것으로 해야 할지에 대한 문제가 생긴다.


방에 입장하고나서 방장이 `게임 시작` 버튼을 통해 게임을 시작한다.
(유저들에게 준비 버튼이 없다고 가정)

1. 클라이언트(방장)의 `게임 시작` 버튼 클릭을 통해 서버에게 게임 시작을 요청한다.
2. 서버는 모든 클라이언트에게 `게임 시작`을 알린다.
3. 방장 이외의 모든 유저의 그림 공유(소켓) 요청을 막는다.
4. 또한 서버에서 클라이언트(방장)에게 단어를 제공한다.
	- 여러 단어 선택시 다음을 추가하여 진행한다.

		1. 클라이언트(방장)에게 n개의 단어를 제공한다.
		2. 클라이언트(방장)의 웹 화면에서 단어의 버튼을 나타낸다.

		3. 클라이언트(방장)이 버튼을 클릭하여 서버에 단어 선택을 요청한다.
5. 서버는 모든 클라이언트들에게 카운트다운 시작을 알린다.
6. 정해진 시간이 종료가 되면 서버에 턴 종료를 요청한다.
7. 6번의 요청이 왔거나, 서버에서 방장이외의 모든 클라이언트가 채팅으로 정답을 맞췄다면 턴 종료를 모든 클라이언트에게 알린다.

	- `Q1`. 이 내용은 백 엔드에서 처리하는 방법이다. 프론트 엔드에서 처리하는 것이 더 좋은 것인지 모른다.

	- 예외. 라운드 종료 처리

		1. 하나의 라운드가 종료되었으면 새로운 라운드의 시작의 내용으로 정보를 채운다.
			ex)
			```json
			{
				턴 관련 데이터 ...,
				"curRound": 2,
				"totalRound": 3,
				"newRound": True,
			}
			```
		- 예외. 모든 라운드 종료

			1. 클라이언트에게 모든 라운드 종료 내용의 데이터를 보내서 알린다.
			```json
			{
				턴 관련 데이터 ...,
				"curRound": 2,
				"newRound": True
			}
			```

			2. 클라이언트는 내용을 받으면 웹 화면은 처음 게임 대기 화면이 된다.

		2. 다음 라운드의 시작으로 정보를 보낸다.

8. 턴에 대한 모든 내용을 초기화한다.

- **발생하는 문제**
	- `Q1`
		- 논의하여 결정해야할 문제이다.
		- 정답이 맞고 틀리고에 대한 내용은 소켓을 통해서 통신이 가능하다.
		- 게임 시작, 다음 턴과 다음 라운드, 게임 종료는 어떤 방식으로 해야할까 ?
	- `Q2`
		- 백 엔드에서 처리를 하게된다면 프론트 엔드에서는 받은 내용을 그대로 웹 화면에 보여주면된다.
		- 프론트 엔드에서 처리할 경우 자바스크립트 코드로 노출이 될 수 있다. 그렇다면 이것을 해결할 수 있을까? -> 이 부분이 어쩔 수 없는 부분인지 모르겠다.

## 유저 입장
---

1. 방 입장시에 채팅 입장과 동시에 로그인한 정보(세션)를 서버에 보낸다.

	- 이유. 클라이언트가 처음 로그인시에 정보를 갖고있게하고 이것을 사용하면 무결성? 보안? 문제가 생길 수 있다.
2. 서버는 이 정보를 받고 DB에 쿼리 요청, 요청한 정보를 받아 클라이언트에게 정보를 보낸다.
3. 클라이언트는 이 정보를 웹에 나타낸다.

## 그림 공유
---

html5 canvas 를 이용해서 html 위에서 그림을 그리는 환경을 생각.

한 사람이 마우스를 움직이는 이벤트를 처리하기 위해서 서버에서 마우스 좌표를 받아와 모두에게 뿌려야 함
-> WebSocket or Socket.io 필요

그림 공유는 채팅 소켓과 따로 동작으로 생각을 진행

1. 클라이언트는 서버와 소켓 연결 요청을 한다.

2. 서버는 연결 요청을 받고 클라이언트의 요청을 계속 받는 상태가 된다.
3. 하나의 클라이언트에서 현재 마우스의 좌표, 이전 마우스의 좌표, 그림 그리는 타입 등을 서버에 보낸다.
4. 서버에서는 이 내용을 모든 클라이언트에게 보낸다.
5. 모든 클라이언트는 이 내용을 받아 canvas에 내용에 맞는 그림을 그린다.

## 공통 사항
---

- **WebSocket vs Socket.io**
	서버와 클라이언트의 양방향 통신을 가능케하는 방법

	- WebSocket
		Html5 에서 제공하는 양방향 통신 프로토콜

		브라우저마다 호환이 다른 제약이 있다.
	- Socket.io
		WebSocket, FlashSocket, Ajax Long Polling, Ajax Multi part Streaming, IFrame, JSONP Polling을 하나의 API로 추상화한 것.

		브라우저와 웹 서버의 종류와 버전을 파악하여 가장 적합한 기술을 선택하여 사용하는 방식

		개발자가 각 기술을 깊이 이해하지 못하거나 구현 방법을 잘 알지 못해도 사용할 수 있다.

	- 결론
		Socket.io는 추상화 API이므로 WebSocket의 상위 개념이라고 볼 수도 있다. 따라서 Socket.io를 사용하면 호환 문제가 없이 개발이 가능하다.

- **DB 선정(RDBMS vs NoSql)**

	RDBMS
	- 쿼리를 통해 정보를 저장, 삭제
	- 2차원 테이블 형태로 데이터를 저장한다.
	- 정보가 자주 바뀌는 것에 유리하다.
	- 엄격한 스키마가 있고 데이터의 형태가 정해진다.
	- 유연한 데이터 저장이 불가하다.
	- 데이터의 중복을 피하는 `관계`가 있다.

	NoSql
	- 스키마와 관계가 존재하지 않는다.
	- 스키마가 없기 때문에 하나의 공간에 여러개의 다른 종류 데이터를 저장할 수 있다.
	- 데이터베이스의 수평적 확장이 가능하다. (수평적 확장이란 )
	- 관계가 없기 때문에 데이터를 변경할 때 관련된 모든 것을 찾아서 수정해줘야 한다.

	논의 필요..
